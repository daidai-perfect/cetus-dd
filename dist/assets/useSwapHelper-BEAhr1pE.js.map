{"version":3,"file":"useSwapHelper-BEAhr1pE.js","sources":["../../src/types/swap.ts","../../src/hooks/common/useGetPoolListByCoinType.ts","../../src/hooks/swap/useSwapHelper.ts"],"sourcesContent":["import { RouterData } from '@cetusprotocol/aggregator-sdk'\n\nexport enum AggregatorProvider {\n  CETUS = 'CETUS',\n  // DEEPBOOK = 'DEEPBOOK',\n  KRIYA = 'KRIYA',\n  KRIYAV3 = 'KRIYAV3',\n  FLOWX = 'FLOWX',\n  FLOWXV3 = 'FLOWXV3',\n  AFTERMATH = 'AFTERMATH',\n  METASTABLE = 'METASTABLE',\n  HAEDAL = 'HAEDAL',\n  VOLO = 'VOLO',\n  AFSUI = 'AFSUI',\n  DEEPBOOKV3 = 'DEEPBOOKV3',\n  SCALLOP = 'SCALLOP',\n  BLUEMOVE = 'BLUEMOVE',\n  TURBOS = 'TURBOS',\n  SPRINGSUI = 'SPRINGSUI',\n  BLUEFIN = 'BLUEFIN',\n  HAEDALPMM = 'HAEDALPMM',\n  ALPHAFI = 'ALPHAFI',\n  STEAMM = 'STEAMM',\n  STEAMM_OMM = 'STEAMM_OMM',\n  OBRIC = 'OBRIC',\n  HAWAL = 'HAWAL'\n}\n\nexport type AggregatorDex = {\n  name: string\n  id: AggregatorProvider | string\n  logo: string\n  type: string\n  sort: number\n  groupId?: string\n  subItems?: AggregatorDex[]\n}\n\nexport type SwapRouterData = {\n  routerData?: RouterData\n  fromAmountUi?: string\n  toAmountUi?: string\n  byAmountIn: boolean\n  isDegrade: boolean //ÊòØÂê¶ÊòØÈôçÁ∫ß\n  uuid: string\n  errorCode?: AggregatorServerErrorCode\n}\n\nexport type SwapRouterFormat = {\n  router_summery: string\n  providers: AggregatorProvider[]\n  routers: {\n    percentage: string\n    paths: {\n      from_type: string\n      to_type: string\n      fee_rate: string\n      pool_address: string\n      provider: AggregatorProvider\n    }[]\n  }[]\n}\n\nexport enum AggregatorServerErrorCode {\n  CalculateError = 10000,\n  NumberTooLarge = 10001,\n  NoRouter = 10002,\n  InsufficientLiquidity = 10003,\n  HoneyPot = 10004\n}\n\nexport enum SwapWidgetStep {\n  TradeInputPage = 'TradeInput',\n  TradeStatus = 'TradeStatus',\n  SelectTokenPage = 'SelectToken',\n  TradeConfirmPage = 'TradeConfirm',\n  RoutePage = 'Route',\n  TradeSetting = 'TradeSetting',\n  SlippageSetting = 'SlippageSetting'\n}\n\nexport type TransactionMode = 'Default' | 'Fast Mode'\n","import useGlobalStore from '@/store/common/global'\nimport useGetPoolList, { GetPoolListParams } from '../pool/useGetPoolList'\n\nexport function useGetPoolListByCoinType(useLocal: boolean = true) {\n  const { poolApiMap, setPoolApiMap } = useGlobalStore()\n  const { getPoolList, getLocalJsonPoolList, getLocalJsonPoolAddress } = useGetPoolList()\n\n  const getPoolListByCoinType = async (fromCoin: string, toCoin: string) => {\n    if (fromCoin && toCoin) {\n      const sortedTypes = [fromCoin, toCoin].sort()\n      const cacheKey = `${sortedTypes[0]}_${sortedTypes[1]}`\n      const cacheValue = poolApiMap[cacheKey]\n      if (cacheValue) {\n        return cacheValue\n      }\n      const params: GetPoolListParams = {\n        coin_type: `${fromCoin},${toCoin}`,\n        display_all_pools: true,\n        offset: 0,\n        limit: 100,\n        order_by: '-tvl',\n        no_incentives: true,\n        has_farming: true,\n        has_mining: true\n      }\n\n      let res = useLocal ? await getLocalJsonPoolList(params) : undefined\n\n      if (res === undefined || res.list.length === 0) {\n        res = await getPoolList(params)\n      }\n      const poolApiList = res.list\n      if (poolApiList.length > 0) {\n        poolApiMap[cacheKey] = poolApiList\n        setPoolApiMap(cacheKey, poolApiList)\n        return poolApiList\n      }\n    }\n\n    return []\n  }\n\n  const getPoolAddressByCoinType = async (fromCoin: string, toCoin: string) => {\n    if (fromCoin && toCoin) {\n      const sortedTypes = [fromCoin, toCoin].sort()\n      const cacheKey = `${sortedTypes[0]}_${sortedTypes[1]}`\n      if (useLocal) {\n        const localList = await getLocalJsonPoolAddress(fromCoin, toCoin)\n\n        if (!localList || localList.length === 0) {\n          const cacheValue = poolApiMap[cacheKey]\n          if (cacheValue) {\n            return cacheValue.map(pool => pool.poolAddress)\n          }\n        } else {\n          return localList\n        }\n      }\n\n      const params: GetPoolListParams = {\n        coin_type: `${fromCoin},${toCoin}`,\n        display_all_pools: true,\n        offset: 0,\n        limit: 100,\n        order_by: '-tvl',\n        no_incentives: true,\n        has_farming: true,\n        has_mining: true\n      }\n\n      const res = await getPoolList(params)\n      if (res) {\n        const poolApiList = res.list\n        if (poolApiList.length > 0) {\n          poolApiMap[cacheKey] = poolApiList\n          setPoolApiMap(cacheKey, poolApiList)\n          return poolApiList.map(pool => pool.poolAddress)\n        }\n      }\n    }\n\n    return []\n  }\n\n  return {\n    getPoolListByCoinType,\n    getPoolAddressByCoinType\n  }\n}\n","import { AggregatorProvider, SwapRouterData, SwapRouterFormat } from '@/types/swap'\nimport { useGetToken } from '@cetus/hooks/src/useToken'\nimport { CoinType, Token } from '@cetus/types'\nimport { d, extractStructTagFromType } from '@cetusprotocol/cetus-sui-clmm-sdk'\nimport { useEffect, useMemo, useState } from 'react'\nimport { useGetPoolListByCoinType } from '../common/useGetPoolListByCoinType'\n\n/**\n * Ëé∑ÂèñÂ±ïÁ§∫PriceAccept RouterData\n * @param originData\n * @returns\n */\nexport function useGetPriceAcceptRouterData(originData?: SwapRouterData, newData?: SwapRouterData) {\n  const priceAcceptRouterData = useMemo(() => {\n    if (newData && originData) {\n      if (originData.byAmountIn) {\n        if (!d(originData.toAmountUi).eq(newData.toAmountUi || '0')) {\n          return newData\n        }\n      } else {\n        if (!d(originData.fromAmountUi).eq(newData.fromAmountUi || '0')) {\n          return newData\n        }\n      }\n\n      return undefined\n    }\n    return undefined\n  }, [newData, originData])\n\n  return { priceAcceptRouterData }\n}\n\n/**\n * ËÆ°ÁÆó‰∫§ÊòìÁöÑamountLimit\n * @param slippage\n * @param routerData\n * @returns\n */\nexport function useGetAmountLimit(slippage: string | number, routerData?: SwapRouterData) {\n  const amountLimit = useMemo(() => {\n    if (routerData && routerData.routerData) {\n      const { byAmountIn, fromAmountUi, toAmountUi } = routerData\n      if (byAmountIn) {\n        return d(toAmountUi)\n          .mul(d(1).sub(d(slippage)))\n          .toString()\n      } else {\n        return d(fromAmountUi)\n          .mul(d(1).add(d(slippage)))\n          .toString()\n      }\n    }\n\n    return undefined\n  }, [slippage, routerData])\n\n  return { amountLimit }\n}\n\n/**\n * ÂØπRouterData ËøõË°åÊ†ºÂºèÂåñÂ§ÑÁêÜ\n * @returns\n */\nexport function useFormatSwapRouter(routerData?: SwapRouterData) {\n  const { fetchTokenInfo } = useGetToken()\n  const [formatSwapRouter, setFormatSwapRouter] = useState<any>({})\n  const toFormatSwapRouter = async () => {\n    if (routerData && routerData.routerData) {\n      const providers: string[] = []\n      const totalAmount = routerData.byAmountIn ? routerData.routerData.amountIn.toString() : routerData.routerData.amountOut.toString()\n      const routers: any[] = []\n      const notFoundList: string[] = []\n      let totalPercentage = d(0)\n      // routerData.routerData.routes.forEach((route, index) => {\n      const list = routerData?.routerData?.routes || []\n      for (let index = 0; index < list.length; index++) {\n        const route = list[index]\n        const routeF: any = {}\n        const amount = routerData.byAmountIn ? route.amountIn.toString() : route.amountOut.toString()\n        if (index === routerData!.routerData!.routes.length - 1) {\n          routeF.percentage = d(1).sub(totalPercentage).toFixed(2)\n        } else {\n          routeF.percentage = d(amount).div(totalAmount).toFixed(2)\n        }\n        totalPercentage = d(totalPercentage).add(routeF.percentage)\n        const pathsF: any[] = []\n        // route.path.forEach(path => {\n        for (let j = 0; j < route?.path?.length; j++) {\n          const path = route?.path?.[j]\n          if (!providers.includes(path.provider)) {\n            providers.push(path.provider)\n          }\n          const from_type = extractStructTagFromType(path.from).full_address\n          const to_type = extractStructTagFromType(path.target).full_address\n          const tokenMap = await fetchTokenInfo<string[]>([from_type, to_type])\n          const fromCoinInfo = tokenMap?.get(from_type)\n          const toCoinInfo = tokenMap?.get(to_type)\n          if (!fromCoinInfo) {\n            if (notFoundList.includes(from_type)) {\n              notFoundList.push(from_type)\n            }\n          }\n          if (!toCoinInfo) {\n            if (notFoundList.includes(to_type)) {\n              notFoundList.push(to_type)\n            }\n          }\n          const notShowPoolAddress =\n            path.provider === AggregatorProvider.SCALLOP || path.provider === AggregatorProvider.FLOWX || path.provider === AggregatorProvider.FLOWXV3\n          pathsF.push({\n            from_type,\n            to_type,\n            pool_address: notShowPoolAddress ? '' : path.id,\n            fee_rate: path.feeRate,\n            provider: path.provider as AggregatorProvider\n          })\n        }\n        routeF.paths = pathsF\n        routers.push(routeF)\n      }\n      if (notFoundList.length > 0) {\n        const coinTypeList = notFoundList?.map(item => item)\n        await fetchTokenInfo<CoinType[]>(coinTypeList as CoinType[])\n      }\n      const info: SwapRouterFormat = {\n        router_summery: `${routerData.routerData.routes.length} Streams`,\n        providers: providers as AggregatorProvider[],\n        routers\n      }\n      setFormatSwapRouter(info)\n      return\n    }\n\n    setFormatSwapRouter(undefined)\n  }\n\n  useEffect(() => {\n    toFormatSwapRouter()\n  }, [routerData])\n  // const formatSwapRouter = useMemo(() => {\n  //   if (routerData && routerData.routerData) {\n  //     const providers: string[] = []\n  //     const totalAmount = routerData.byAmountIn ? routerData.routerData.amountIn.toString() : routerData.routerData.amountOut.toString()\n  //     const routers: any[] = []\n\n  //     const notFoundList: string[] = []\n\n  //     let totalPercentage = d(0)\n  //     routerData.routerData.routes.forEach((route, index) => {\n  //       const routeF: any = {}\n  //       const amount = routerData.byAmountIn ? route.amountIn.toString() : route.amountOut.toString()\n\n  //       if (index === routerData!.routerData!.routes.length - 1) {\n  //         routeF.percentage = d(1).sub(totalPercentage).toFixed(2)\n  //       } else {\n  //         routeF.percentage = d(amount).div(totalAmount).toFixed(2)\n  //       }\n\n  //       totalPercentage = d(totalPercentage).add(routeF.percentage)\n\n  //       const pathsF: any[] = []\n\n  //       route.path.forEach(path => {\n  //         if (!providers.includes(path.provider)) {\n  //           providers.push(path.provider)\n  //         }\n\n  //         const from_type = extractStructTagFromType(path.from).full_address\n  //         const to_type = extractStructTagFromType(path.target).full_address\n\n  //         const fromCoinInfo = getTokenInfo(from_type)\n  //         const toCoinInfo = getTokenInfo(to_type)\n\n  //         if (!fromCoinInfo) {\n  //           if (notFoundList.includes(from_type)) {\n  //             notFoundList.push(from_type)\n  //           }\n  //         }\n\n  //         if (!toCoinInfo) {\n  //           if (notFoundList.includes(to_type)) {\n  //             notFoundList.push(to_type)\n  //           }\n  //         }\n\n  //         const notShowPoolAddress =\n  //           path.provider === AggregatorProvider.SCALLOP || path.provider === AggregatorProvider.FLOWX || path.provider === AggregatorProvider.FLOWXV3\n\n  //         pathsF.push({\n  //           from_type,\n  //           to_type,\n  //           pool_address: notShowPoolAddress ? '' : path.id,\n  //           fee_rate: path.feeRate,\n  //           provider: path.provider as AggregatorProvider\n  //         })\n  //       })\n\n  //       routeF.paths = pathsF\n  //       routers.push(routeF)\n  //     })\n\n  //     if (notFoundList.length > 0) {\n  //       for (const info in notFoundList) {\n  //         fetchTokenInfo(info)\n  //       }\n  //     }\n\n  //     const info: SwapRouterFormat = {\n  //       router_summery: `${routerData.routerData.routes.length} Streams`,\n  //       providers: providers as AggregatorProvider[],\n  //       routers\n  //     }\n\n  //     return info\n  //   }\n  //   return undefined\n  // }, [routerData])\n\n  return { formatSwapRouter }\n}\n\n/**\n * ÂæóÂà∞ swap ÈôçÁ∫ß Ê±†Â≠êÂú∞ÂùÄÂàóË°®\n * @returns\n */\nexport function useGetSwapPoolAddressList() {\n  const { getPoolAddressByCoinType } = useGetPoolListByCoinType(true)\n\n  const getSwapPoolAddress = async (from?: Token, to?: Token) => {\n    if (from && to) {\n      const list = await getPoolAddressByCoinType(from.coin_type, to.coin_type)\n      console.log('üöÄ ~ getSwapPoolAddress ~ list:', list)\n\n      return list\n    }\n\n    return []\n  }\n\n  return {\n    getSwapPoolAddress\n  }\n}\n\n/**\n * ËÆ°ÁÆóswap ‰ª∑Ê†º√ü\n * @param fromAmount\n * @param toAmount\n */\nexport function useGetSwapPrice(fromAmount?: string, toAmount?: string) {\n  return useMemo(() => {\n    if (fromAmount && toAmount && +fromAmount && +toAmount) {\n      return d(toAmount).div(fromAmount).toString()\n    }\n    return '0'\n  }, [fromAmount, toAmount])\n}\n"],"names":["AggregatorProvider","AggregatorServerErrorCode","SwapWidgetStep","useGetPoolListByCoinType","useLocal","poolApiMap","setPoolApiMap","useGlobalStore","getPoolList","getLocalJsonPoolList","getLocalJsonPoolAddress","useGetPoolList","fromCoin","toCoin","sortedTypes","cacheKey","cacheValue","params","res","poolApiList","localList","pool","useGetPriceAcceptRouterData","originData","newData","useMemo","d","useGetAmountLimit","slippage","routerData","byAmountIn","fromAmountUi","toAmountUi","useFormatSwapRouter","fetchTokenInfo","useGetToken","formatSwapRouter","setFormatSwapRouter","useState","toFormatSwapRouter","providers","totalAmount","routers","notFoundList","totalPercentage","list","_a","index","route","routeF","amount","pathsF","j","_b","path","_c","from_type","extractStructTagFromType","to_type","tokenMap","fromCoinInfo","toCoinInfo","notShowPoolAddress","coinTypeList","item","info","useEffect","useGetSwapPoolAddressList","getPoolAddressByCoinType","from","to","useGetSwapPrice","fromAmount","toAmount"],"mappings":"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"}